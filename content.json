{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2024/04/26/hello-world/"},{"title":"xyctf2023-re-writeup","text":"感觉第一周最好玩，没了。 聪明的信使九位凯撒。flag{Y0u_KnOw_Crypt0_14_v3ry_Imp0rt@nt!} 给阿姨倒一杯卡布奇诺代码没去符号，一切都很明显，不多赘述加密是魔改 xxtea。魔改了三处，其中还涉及一个全局变量 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from ctypes import *def encrypt(v, k): v0, v1 = c_uint32(v[0]), c_uint32(v[1]) v0.value ^= 0x5F797274 v1.value ^= 0x64726168 delta = 0x6E75316C k0, k1, k2, k3 = k[0], k[1], k[2], k[3] total = c_uint32(0) for i in range(32): total.value += delta v0.value += ((v1.value &lt;&lt; 4) + k0) ^ (v1.value + total.value) ^ ((v1.value &gt;&gt; 5) + k1) ^ (total.value + i) v1.value += ((v0.value &lt;&lt; 4) + k2) ^ (v0.value + total.value) ^ ((v0.value &gt;&gt; 5) + k3) ^ (total.value + i) print(hex(v0.value), hex(v1.value)) return v0.value, v1.valuedata1 = 0x5F797274data2 = 0x64726168def decrypt(v, k): global data1 global data2 v0, v1 = c_uint32(v[0]), c_uint32(v[1]) t_1 = v[0] t_2 = v[1] delta = 0x6E75316C k0, k1, k2, k3 = k[0], k[1], k[2], k[3] total = c_uint32(delta * 32) for i in range(31, -1, -1): v1.value -= ((v0.value &lt;&lt; 4) + k2) ^ (v0.value + total.value) ^ ((v0.value &gt;&gt; 5) + k3) ^ (total.value + i) v0.value -= ((v1.value &lt;&lt; 4) + k0) ^ (v1.value + total.value) ^ ((v1.value &gt;&gt; 5) + k1) ^ (total.value + i) total.value -= delta # print(hex(v0.value), hex(v1.value)) v0.value ^= data1 v1.value ^= data2 data1 = t_1 data2 = t_2 return v0.value, v1.value# testif __name__ == &quot;__main__&quot;: # value = [0x880012C7, 0x58EE54] value = [0x9B28ED45, 0x145EC6E9, 0x5B27A6C3, 0xE59E75D5, 0xE82C2500, 0xA4211D92, 0xCD8A4B62, 0xA668F440] key = [0x65766967, 0x756F795F, 0x7075635F, 0x6165745F] # 解密 flag2 = b&quot;&quot; for i in range(0, len(value), 2): res = decrypt(value[i:i+2], key) flag2 += res[0].to_bytes(4, 'little') + res[1].to_bytes(4, 'little') print(hex(res[1])) print(flag2) 何须相思煮余年数据开头是 0x55，结尾是 0xc3，可认为是汇编机器码转化为 hex 数据后 ida 查看（注意这里如果复制到 010editor 后使用 paste from hex text 会吞一些数据。）直接解即可。b’XYCTF{5b3e07567a9034d06851475481507a75}’ 今夕是何年ida 和 die 都认为是未知架构。搜索架构码 or 搜索 cpu 特征可知可能是龙芯架构。配置 qemu 环境模拟执行 馒头 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990tree = [0x8DE, 0x395, 0x1BE, 0x0D9, 0x06A, 0x033, 0x014, 0x00F, 0x011, 0x0E5, 0x072, 0x010, 0x00B, 0x1D7, 0x0E9, 0x074, 0x00E, 0x00D, 0x0EE, 0x076, 0x00C, 0x007, 0x549, 0x22D, 0x0F8, 0x07B, 0x006, 0x018, 0x135, 0x089, 0x043, 0x003, 0x005, 0x0AC, 0x054, 0x004, 0x001, 0x31C, 0x17F, 0x0BA, 0x059, 0x002, 0x008, 0x0C5, 0x061, 0x030, 0x017, 0x00A, 0x015, 0x19D, 0x0CB, 0x065, 0x016, 0x009, 0x0D2, 0x068, 0x013, 0x012]fake_flag = &quot;1&quot;*24print(fake_flag)len_tree = len(tree)print(len_tree)flag = [0] * 25data = 0count = 0dcount = 0print(chr(0x65))for i in range(len_tree-1, -1, -1): if tree[i] &lt; 25: data = 0 dcount = 1 count += 1 continue elif tree[i] &lt; 0x7f: flag[tree[i+dcount]] = tree[i] data = tree[i] dcount += 2 count -= 1 elif count &gt; 0: flag[tree[i+dcount]] = tree[i] - data # flag.append(tree[i] - data) data += tree[i] count -= 1 dcount += 2print(flag)# print(bytes(flag), len(flag))print(hex(sum(flag)))flag = [0xac - 0x54, 0x59, 0x43, 0x54, 0x89-0x43, 0x7b, 0xee-0x76, 0xba-0x59, 0xcb-0x65, 0x61-0x30, 0xe5-0x72, 0x76, 0xe9-0x74, 0x74, 0x6a-0x33, 0x72, 0xd9-0x6a, 0xd2-0x68, 0x68, 0x33, 0xc5-0x61, 0x65, 0x30, 0xf8-0x7b]print(bytes(flag)) 喵喵喵的 flag 碎了一地推理游戏同个函数有不被解析的部分 你是真的大学生吗？汇编阅读。相邻两位依次异或 123456789cipher = [0x76, 0x0E, 0x77, 0x14, 0x60, 0x06, 0x7D, 0x04, 0x6B, 0x1E, 0x41, 0x2A, 0x44, 0x2B, 0x5C, 0x03, 0x3B, 0x0B, 0x33, 0x05]for i in range(len(cipher)-1, -1, -1): cipher[i] = (cipher[i] ^ cipher[i-1])print(bytes(cipher)) 输出会有一位偏移，修复一下即可。xyctf{you_know_8086} 砸核桃NsPack，esp 定律或者附加下断点脱壳esp：pushad 后对 esp 的地址下硬件访问断点，待到 popad 或代码到 0x401000+后使用 dump 插件 dump 并调整最后发现是一个异或 1234567891011key = b&quot;this_is_not_flag&quot;cipher = [0x00000012, 0x00000004, 0x00000008, 0x00000014, 0x00000024, 0x0000005C, 0x0000004A, 0x0000003D, 0x00000056, 0x0000000A, 0x00000010, 0x00000067, 0x00000000, 0x00000041, 0x00000000, 0x00000001, 0x00000046, 0x0000005A, 0x00000044, 0x00000042, 0x0000006E, 0x0000000C, 0x00000044, 0x00000072, 0x0000000C, 0x0000000D, 0x00000040, 0x0000003E, 0x0000004B, 0x0000005F, 0x00000002, 0x00000001, 0x0000004C, 0x0000005E, 0x0000005B, 0x00000017, 0x0000006E, 0x0000000C, 0x00000016, 0x00000068, 0x0000005B, 0x00000012, 0x00000000, 0x00000000]for i in range(42): cipher[i] ^= key[i % len(key)]print(bytes(cipher)) babyUnity该题可直接用 il2cppdumper 脱脱完后建议直接用 dnspy 分析 assembly，可看见几个函数的偏移在 ida 里直接 ctrl+g 飞过去，可看得函数逻辑（有些是空函数，空就别管） 123456789import base64cipher = b&quot;\\x58\\x49\\x63\\x4B\\x59\\x4A\\x55\\x38\\x42\\x75\\x68\\x3A\\x55\\x65\\x56\\x3A\\x42\\x4B\\x4E\\x7B\\x55\\x5B\\x4A\\x76\\x55\\x4C\\x3F\\x3F\\x56\\x75\\x5A\\x3F\\x43\\x58\\x4A\\x3B\\x41\\x58\\x5E\\x7B\\x41\\x65\\x5D\\x67\\x41\\x5B\\x5D\\x67\\x55\\x65\\x63\\x62\\x40\\x4B\\x5D\\x65\\x69\\x5E\\x32\\x32&quot;cipher = list(cipher)for i in range(len(cipher)): cipher[i] ^= 0xfcipher = base64.b64decode(bytes(cipher))print(cipher) XYCTF{389f6900-e12d-4c54-a85d-64a54af9f84c} DebugMeJEB 打开，程序被 vm 混淆MainActivity 里有暴露 cipher 数组，程序无输入，点击按键后默认只弹出无用信息，同时相邻部分的另一个 Toast 弹出有和 cipher 有关的参数。可推测需通过调试篡改到弹出 flag 的逻辑。追踪调用：分析 What 类或 x 的交叉引用树，可知该类是做了 tea 加解密类。x 调用了解密算法key 的初始化：tea 算法特征：除此之外还进行了 base64 和稍微的变形,並修复了 cipher 的 base64 格式（有一个 url 格式的%2b 需替换为+）这里我静态不知为何解不出，那么尝试用 frida 动态解。frida 脚本思路是：hook 一个被执行的函数，篡改为 What.x 解密函数并使用修复后的密文作为参数。最终选择 hook 了 Debug 的 check 函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 检查java runtime可用性// frida -U -f com.xyctf.ezapk -l .\\hook_1.jsif (Java.available) { Java.perform(function () { var What = Java.use(&quot;com.xyctf.ezapk.What&quot;); var x = What.x; x.implementation = function (arg) { console.log(&quot;hook in&quot;); var retVal = this.x(arg); console.log(retVal); return retVal; }; var Debug = Java.use(&quot;android.os.Debug&quot;); var isDebuggerConnected = Debug.isDebuggerConnected; isDebuggerConnected.implementation = function () { console.log(&quot;in debug check&quot;); var a = What.x( &quot;WikFhRxyYjoSJ8mMbM3fRwty/74bc7Ip7ojqenHaSqc9wDv3JDG9XfV6xEiC7Eg1RWTUa4LaM+D0W+PKanSA5w==&quot; ); console.log(&quot;a&quot;); return false; }; });} else console.log(&quot;Java not available&quot;); easy language搜字符串容易判断是 aes ecb 加密，但 key 很难找，且没有 aes 常量暴露但是，又发现有 CryptoAPI 的字样猜测是动态注册调用，尝试 hook确实使用了，但是 key 试了 RUUU 和 KSSM 都不对但是又看到底下的 xyctf 和 abctf，长度刚好 16 位，满足 aeskey 的要求尝试： 12345678910111213141516171819from Crypto.Cipher import AESimport base64cipher1 = &quot;adaGb8kVFQpPVFMcwWQRybbInjf4Q9Iu+f6k9Nw=&quot;cipher2 = &quot;qBr4adaGb8kVFQpPVFMcwWQRybbInjf4Q9Iu+f6k9Nw=&quot;cipher3 = &quot;RZy/zVEWMFxaCbzChAg8x26XZYr51rNVnM+zBoBp3gya93L9QQXpFRin1JE33vyx&quot;tmp = &quot;oVFXvP32lAb6S1bs5xj2mg==&quot;key = b&quot;welcometoxyctf!!&quot;a = base64.b64decode(cipher3)b = AES.new(key, AES.MODE_ECB)print(b.decrypt(a) XYCTF{y0u_@r3_v3ry_g00d_a7_E_l@ngu@ge} ez_enc本题的其它计算都不算重要，重要的是 mod 20.加密带有 mod 20，会丢失信息，因此不能单纯逆推。而事实上，mod 20 不仅是一个解题限制，更是解题线索.一个可见字符的大小范围是 0x20-0x7e。而当中 mod 20，同一个数字约有 5-6 种的可能。同时加密算法中，flag[i]同时受 flag[i]自己和 flag[i+1]影响，也就是受前一位解密的影响。也就是说我们从最后一位往前推，每一位都有约 5 种可能，而每一位都是上一位推理的继续。那么事实上，这个就是以 flag 最后一位为根节点，以 mod 20 为运算推理出的一个树，某一条能走到树最后一层的路径就是最终的 flag。那么解题的关键找到了。剩下的就是让解题变为可行，这里分析题目有几个约束可用：①flag[i]和 flag[i+1]强相关，如何 flag[i+1]，也就是上一位的值不对，那 flag[i]大概率也不对②flag[i]正确的情况为：flag[i]在推理时小于 20（这里的 flag[i]是由 flag[i+1]推出的 flag[i]%20）且 flag[i]推理完毕后&gt;=0x20,&lt;=0x7e那么写一个递归算法实现这个思路： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263cipher = bytes.fromhex( &quot;2724170b5003c80c1f173655cb2de9320e1126020c07fc273d2ded3559eb3c3ee47d&quot;)#lag{!_r3ea11y_w4nt_@_cu7e_s1$ter}cipher = list(cipher)key = b&quot;IMouto&quot;flag = []flag.append(cipher[-1])def trace_back(flag:list,p:int): # 逆推求解cipher[p]的值 #print(bytes(flag),p) if p == -1: flag.reverse() print(bytes(flag)) flag.reverse() flag.pop() return a = cipher[p] a ^= key[p%6] a -= flag[-1] # 减去上一个推得的值，也就是减去cipher[p+1].此时的值是cipher[p]_原初%20 if a &gt;= 20 or a &lt; 0: # 上一个值不合适，pop flag.pop() return else: for i in range(0,7): b = a + i * 20 if b &gt;= 0x20 and b &lt;= 0x7f: #print(p,b) flag.append(b) trace_back(flag,p-1) # 当进行到最后的时候pop出来 flag.pop()trace_back(flag,len(cipher)-2) ezcube魔方，约束右手公式和 12 步在网上搜到了同款初始情况：魔方入门解法第 7 步：调整顶层棱块位置 - 爱魔方 (i-mofang.com) ezmath我认为出得很差的一个题。python 3.8 打包为 exe，使用 python3.8 环境下的 pyinstxtractor.py 解包，使用 uncompyle6 反编译。 1234flag = [ord(i) for i in input('flag:')]if len(flag) == 32: if sum([flag[23] for _ in range(flag[23])]) + sum([flag[12] for _ in range(flag[12])]) + sum([flag[1] for _ in range(flag[1])]) - sum([flag[24] for _ in range(222)]) + sum([flag[22] for _ in range(flag[22])]) + sum([flag[31] for _ in range(flag[31])]) + sum([flag[26] for _ in range(flag[26])]) - sum([flag[9] for _ in range(178)]) - sum([flag[29] for _ in range(232)]) + sum([flag[17] for _ in range(flag[17])]) - sum([flag[23] for _ in range(150)]) - sum([flag[6] for _ in range(226)]) - sum([flag[7] for _ in range(110)]) + sum([flag[19] for _ in range(flag[19])]) + sum([flag[2] for _ in range(flag[2])]) - sum([flag[0] for _ in range(176)]) + sum([flag[10] for _ in range(flag[10])]) - sum([flag[12] for _ in range(198)]) + sum([flag[24] for _ in range(flag[24])]) + sum([flag[9] for _ in range(flag[9])]) - sum([flag[3] for _ in range(168)]) + sum([flag[8] for _ in range(flag[8])]) - sum([flag[2] for _ in range(134)]) + sum([flag[14] for _ in range(flag[14])]) - sum([flag[13] for _ in range(170)]) + sum([flag[4] for _ in range(flag[4])]) - sum([flag[10] for _ in range(142)]) + sum([flag[27] for _ in range(flag[27])]) + sum([flag[15] for _ in range(flag[15])]) - sum([flag[15] for _ in range(224)]) + sum([flag[16] for _ in range(flag[16])]) - sum([flag[11] for _ in range(230)]) - sum([flag[1] for _ in range(178)]) + sum([flag[28] for _ in range(flag[28])]) - sum([flag[5] for _ in range(246)]) - sum([flag[17] for _ in range(168)]) + sum([flag[30] for _ in range(flag[30])]) - sum([flag[21] for _ in range(220)]) - sum([flag[22] for _ in range(212)]) - sum([flag[16] for _ in range(232)]) + sum([flag[25] for _ in range(flag[25])]) - sum([flag[4] for _ in range(140)]) - sum([flag[31] for _ in range(250)]) - sum([flag[28] for _ in range(150)]) + sum([flag[11] for _ in range(flag[11])]) + sum([flag[13] for _ in range(flag[13])]) - sum([flag[14] for _ in range(234)]) + sum([flag[7] for _ in range(flag[7])]) - sum([flag[8] for _ in range(174)]) + sum([flag[3] for _ in range(flag[3])]) - sum([flag[25] for _ in range(242)]) + sum([flag[29] for _ in range(flag[29])]) + sum([flag[5] for _ in range(flag[5])]) - sum([flag[30] for _ in range(142)]) - sum([flag[26] for _ in range(170)]) - sum([flag[19] for _ in range(176)]) + sum([flag[0] for _ in range(flag[0])]) - sum([flag[27] for _ in range(168)]) + sum([flag[20] for _ in range(flag[20])]) - sum([flag[20] for _ in range(212)]) + sum([flag[21] for _ in range(flag[21])]) + sum([flag[6] for _ in range(flag[6])]) + sum([flag[18] for _ in range(flag[18])]) - sum([flag[18] for _ in range(178)]) + 297412 == 0: print('yes') 简单格式处理后如下：flag 长 32 位，sum = 0for i in range(32):sum += flag[i]_ flag[i]sum += flag[i]_ （100-300 的一个偶数）sum = -297412可能按照出题人的想法，这题的解法是依据题目简介的提示：初中数学，配平。A^2 + 2AB +B^2 = X。这题每一位 flag 都有平方，也都有乘以一个偶数，那假设每位 flag 是 A，A 乘的那个偶数就是另外的 2B，由此可以推出 flag那这不是很扯吗，题目的解是基于一个很低级的假设。大伙是来做逆向的，不是脑洞数学。 ezrand随机种子随机数算法，因为随机种子根据 time64 得到，而 time64 返回值落在 0xffff 内，所以可爆。中间随机数相关的复杂算法 ida 可能还原不正确，需要按汇编理解。本质上是 rand()%0xff 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int __cdecl main(int argc, const char **argv, const char **envp){ unsigned long v3; // rbx unsigned int v4; // ax int v5; // edi long i; // rsi int rand_value; // eax int cipher[7]; // [rsp+20h] [rbp-50h] char v10; // [rsp+3Ch] [rbp-34h] int v11; // [rsp+3Dh] [rbp-33h] char *input; // [rsp+40h] [rbp-30h] BYREF long v13; // [rsp+50h] [rbp-20h] int v14; // [rsp+58h] [rbp-18h] int v15; // [rsp+5Ch] [rbp-14h] char v16; // [rsp+5Eh] [rbp-12h] v13 = 0; input = 0; v14 = 0; v15 = 0; v16 = 0; cipher[0] = 0xEA6C0C5D; v11 = 0; v3 = -1; cipher[1] = 0x34FC1946; cipher[2] = 0x72362B2; cipher[3] = 0xFB6E2262; cipher[4] = 0xA9F2E8B4; cipher[5] = 0x86211291; cipher[6] = 0x43E98EDB; v10 = 77; v4 = _time64(0); srand(v4); v5 = 0; int rand_arr[29]; // for (i = 0; i &lt; 29; i++) // rand_arr[i] = rand(); v3 = 29; i = 0; for (int seed = 0; seed &lt; 0xffff; seed++) { char flag[30] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}; srand(seed); for (i = 0; i &lt; 29; i++) { int tmp = rand(); int a = tmp &gt;&gt; 32 &gt;&gt; 7; int b = a &gt;&gt; 0x1f; int c = a + b; b = c * 0xff; int d = tmp - b; int tmp2 = *((char *)cipher + i) ^ d; // tmp2 = d; if (tmp2 &gt; 0x7e) break; if (tmp2 &lt; 0x20) break; flag[i] = tmp2; // printf(&quot;%c&quot;, tmp2); } if (strlen(flag) &gt; 1) printf(&quot;%s\\n&quot;, flag); } return 0;} ezUnity此题略微难在 metadata 文件格式修复可对比 babyUnity 或者其它 Unity 文件的 dll，修复后：剩下操作类似 babyUnity能通过 findcrypt 或者分析发现是 aes 123cipher1 = &quot;pNufkEIU9dHjKXYXWiFyrthHYFEfqJAWcPM/t8/zX1w=&quot;key = &quot;a216d5d34c2723f5&quot;iv = &quot;9f68268f755b1363&quot; XYCTF{IL2CPP_1s_intere5t1ng} Trustmemain 是一个没什么用的 rc4，并且和程序对不上。康康别的类有一个对 dex 解密并输出什么的。这里静态解太麻烦了，动态找到安卓机的 data/data 里对应的包，发现确实有东西如：分析 dex 目录的 apk，发现其主要做了一个数据库查找操作。找到数据库：XYCTF{And0r1d_15_V3ryEasy} That’s thislua 字节码在线反编译https://www.luatool.cn/index.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778value = &quot;&quot;output = &quot;&quot;i = 1while true do local temp = string.byte(flag, i) temp = string.char(Xor(temp, 8) % 256) value = value .. temp i = i + 1 if i &gt; string.len(flag) then break endendfor _ = 1, 1000 do x = 3 y = x * 3 z = y / 4 w = z - 5 if w == 0 then print(&quot;This line will never be executed&quot;) endendfor i = 1, string.len(flag) do temp = string.byte(value, i) temp = string.char(temp + 3) output = output .. tempendresult = output:rep(10)invalid_list = { 1, 2, 3}for _ = 1, 20 do table.insert(invalid_list, 4)endfor _ = 1, 50 do result = result .. &quot;A&quot; table.insert(invalid_list, 4)endfor i = 1, string.len(output) do temp = string.byte(output, i) temp = string.char(temp - 1)endfor _ = 1, 30 do result = result .. string.lower(output)endfor _ = 1, 950 do x = 3 y = x * 3 z = y / 4 w = z - 5 if w == 0 then print(&quot;This line will never be executed&quot;) endendfor _ = 1, 50 do x = -1 y = x * 4 z = y / 2 w = z - 3 if w == 0 then print(&quot;This line will also never be executed&quot;) endendrequire(&quot;base64&quot;)obfuscated_output = to_base64(output)obfuscated_output = string.reverse(obfuscated_output)obfuscated_output = string.gsub(obfuscated_output, &quot;g&quot;, &quot;3&quot;)obfuscated_output = string.gsub(obfuscated_output, &quot;H&quot;, &quot;4&quot;)obfuscated_output = string.gsub(obfuscated_output, &quot;W&quot;, &quot;6&quot;)invalid_variable = obfuscated_output:rep(5)if obfuscated_output == &quot;==AeuFEcwxGPuJ0PBNzbC16ctFnPB5DPzI0bwx6bu9GQ2F1XOR1U&quot; then print(&quot;You get the flag.&quot;)else print(&quot;F**k!&quot;)end 存在一些混淆代码，但从密文逆推可以很轻松地找到核心逻辑： 123456789101112131415161718192021222324252627282930313233import base64a = list(b&quot;==AeuFEcwxGPuJ0PBNzbC1WctFnPB5DPzI0bwxWbu9GQ2F1XOR1U&quot;)a.reverse()b = list(base64.b64decode(bytes(a)))print(bytes(a))print(base64.b64decode(bytes(a)), len(b))flag = &quot;&quot;for i in range(len(b)): for l in range(0x20, 0x7f): t = (l ^ 8) + 3 if t == b[i]: flag += chr(l) # b[i] += 1 # b[i] -= 3 # # b[i] &amp;= 0xff # b[i] ^= 8print(flag, len(flag)) XYCTF{5dcbaed781363fbfb7d8647c1aee6c}","link":"/2024/04/28/xyctf2023-re-writeup/"},{"title":"hash拓展攻击与例题hash_append","text":"hash 长度拓展攻击是一个效果还挺“惊人”的攻击。简单的来说，他能在只知道“一部分”密文的情况下，获得和“完整”密文相同的 hash 结果。只要满足条件，这个攻击现在对 MD5、SHA1、SHA256、SHA512 和 SM3 都能生效。 这个攻击的原理是目前这些主流哈希计算的一个薄弱点。这些哈希计算是基于对明文的分组。比如 64 个字节为一组，不满 64 的倍数则 padding 为 64 位。对于每一组的明文来说，它需要与一组“向量”混合加密、输出为一个 hash。而如果不止一组明文，每组明文的 hash 会作为下一组的“向量”，这里的向量可理解为会变的加密密钥。 于是，在分组加密的情况下，实际上是：① 每组独立做明文+向量混合运算② 向量由上一组的运算结果决定（等于）这里要留意这个“独立”。因为这实际上隐含了一个意思：假设有一个八个分组的明文，我们不需要知道前七组的明文，只需要知道最后一组——以及第七组（前七组）的运算结果，就能算出这第八组——也就是整个明文的哈希结果。 更进一步的，把前七组的明文看作 flag，第八组的明文看作独立 padding、append 拓展数据、salt 盐，那么这就是长度拓展攻击了。 以 MD5 为例子： 放到例题中 1234567891011121314151617181920212223242526272829303132333435363738394041424344import osfrom gmssl import sm3, funcwith open('flag') as f: flag = f.read()MySecretInfo = os.urandom(64) # 有密文HashValue = sm3.sm3_hash(func.bytes_to_list(MySecretInfo))print('MySecretInfo Hash:', HashValue) # 有密文hashAppendData = bytes.fromhex(input('Input AppendData: ')) # salt、append数据assert len(AppendData) == 64NewSecretInfo = MySecretInfo + AppendDataGeneratedHash = input('Input NewSecretInfo Hash: ')NewHashValue = sm3.sm3_hash(func.bytes_to_list(NewSecretInfo))print(NewHashValue)if GeneratedHash == NewHashValue: print(flag)else: print('Nope') sm3 的分组标准是 64 位一组，因此 secret 和 appendData 是分别两组，基本要求满足。知晓 secret 的 hash，appendData 自己构造，这就很清晰了。但落到实现上：①gmssl 库会默认在加密时做一个 64 位的 padding② 我们如何将 secret 的 hash 构造成加密的向量？② 可以翻阅库实现解决：首先是 padding 部分：而后是向量 Vector这里我们只需要为这个函数添加一个新的参数，作为 V[0]的初始值即可（同时记得 group_count -1）参考攻击实现：https://github.com/hjzin/SM3LengthExtensionAttack而对于 ①，这里很有趣我们之前的实现逻辑是：知道 Hash(Secret)，知道 append，可知 Hash(Secret+append)而默认 padding 时：Hash(Secret+padding)，知道 append，可知 Hash(Secret+append+padding)发现了么？这两次 hash 的值似乎对不上。 但这里，我要说拓展攻击，是一个很“模板”的攻击。这里不要被 append 这个名词所束缚。它能是 append，它能是 salt，甚至它也能是“padding”——是第一次 hash 的“padding”。阅读 padding 部分的代码可知这个 padding 是很朴素的一个 padding，有变化，但变化不多。明文为一组时 padding 固定是：b’\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00’明文为两组时 padding 固定是：b’\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00’仅仅在末尾会有一些改变。那么我们可以把用第一次 padding 的值去 append，这样就有：Hash(Secret+padding1)，知道 append，可知 Hash(Secret+padding1+padding2)bingo~攻击完成 √参考 exp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#!/usr/bin/env python# -*- coding:utf-8 -*-&quot;&quot;&quot;@Time：2019/10/12@Author: hhzjj@Description：SM3长度扩展攻击 1.随机生成一个secret，算出secret的hash值 2.根据hash值推出第一次压缩之后各个寄存器里的值 3.在secret+padding之后附加一段消息，用上一步寄存器里的值作为IV去加密附加的那段消息，得到hash 4.用sm3去加密secret+padding+m'，得到hash 5.第3步和第4步得到的hash值应该相等&quot;&quot;&quot;from gmssl import sm3, funcimport randomimport my_sm3import structsecret = &quot;3131313131313131313131313131313131313131313131313131313131313131&quot;a = func.bytes_to_list(bytes(secret, encoding='utf-8'))secret_hash = &quot;f6dd54733108fa21bb08102f367787ed9ac388b8bc8311a1e999d5b5d09ba0a6&quot;print(secret_hash)secret_len = len(secret)append_m = b'\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00'pad_str = &quot;&quot;pad = []print(my_sm3.sm3_hash2(func.bytes_to_list(secret.encode()+append_m)))def generate_guess_hash(old_hash, secret_len, append_m): # 攻击关键在于重设vector &quot;&quot;&quot; SM3长度扩展攻击 :param old_hash: secret的hash值 :param secret_len: secret的长度 :param append_m: 附加的消息 :return: hash(secret + padding + append_m) &quot;&quot;&quot; vectors = [] message = &quot;&quot; # 将old_hash分组，每组8个字节, 并转换为整数 for r in range(0, len(old_hash), 8): vectors.append(int(old_hash[r:r + 8], 16)) # # 伪造消息 if secret_len &gt; 64: for i in range(0, int(secret_len / 64) * 64): message += 'a' for i in range(0, secret_len): message += 'a' message = func.bytes_to_list(bytes(message, encoding='utf-8')) # message = padding(message) message.extend(func.bytes_to_list( append_m)) print(&quot;meesage len&quot;, len(message)) return my_sm3.sm3_hash(message, vectors)guess_hash = generate_guess_hash(secret_hash, secret_len, append_m)print(guess_hash)","link":"/2024/04/29/hash%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB%E4%B8%8E%E4%BE%8B%E9%A2%98hash-append/"}],"tags":[{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"Crypto","slug":"Crypto","link":"/tags/Crypto/"}],"categories":[]}