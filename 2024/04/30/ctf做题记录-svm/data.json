{"title":"ctf做题记录-svm","date":"2024-04-30T07:38:52.000Z","source":"_posts/ctf做题记录-svm.md","raw":"---\ntitle: ctf做题记录-svm\ndate: 2024-04-30 15:38:52\ntags: CTF\n---\n\n# 待补完\n\n![alt text](image.png)\n导入表为空，纯静态编译\n经检查初始化和推出程序均空\n![alt text](image-1.png)\n![alt text](image-2.png)\n程序执行会有 input 字符串，这是线索（这里用 ida 远程启动，会有其它信息\n![alt text](image-3.png)\ninput 直接在 string 中搜到，有如下交叉引用：\n![alt text](image-4.png)\n直接下断点动调，发现 1780 是 main 函数，会 printf(input)\n![alt text](image-5.png)\ninit 函数做了一个初始化：\n![alt text](image-6.png)\nsub_402000 是一个大虚拟机，不多赘述。\n那么按照虚拟机的思路对函数重新命名\n```cpp\n__int64 sub_401780()\n{\n  __int64 vm_mem[5]; // [rsp+0h] [rbp+0h] BYREF\n  unsigned __int64 vars28; // [rsp+28h] [rbp+28h]\n\n  vars28 = __readfsqword(0x28u);\n  printf(\"input:\");\n  init(vm_mem, &mem_src, 4096LL, 2677LL);\n  vm(vm_mem);\n  may_printf(vm_mem[0]);\n  may_printf(vm_mem[2]);\n  if ( __readfsqword(0x28u) != vars28 )\n    sub_44C7D0();\n  return 0LL;\n}\n```\n对虚拟机init的一些初始判断：\n```python\n__int64 __fastcall init(struct_vm *vm, __int64 a2, int mem_size, int code_size)\n{\n  __m128i *mem; // rax\n  __int64 code_seg; // rax\n  __int64 result; // rax\n\n  mem = (__m128i *)malloc(4LL * mem_size);\n  vm->mem_size = mem_size;\n  vm->mem = mem;\n  memset(mem, 0, 4 * mem_size);\n  code_seg = malloc(4LL * code_size);\n  vm->code_szie = code_size;\n  vm->code_seg = code_seg;\n  result = sub_401060();\n  vm->ip_point = 0;\n  vm->stack = -1LL;\n  return result;\n}\n```\n在当前这一步，我们可以确定的分析不多，但有一点———该虚拟机似乎缺少了对寄存器的初始化，只进行了两个内存空间——很可能是代码和栈空间的初始化；接下来我们会印证这个想法。\n该虚拟机的指令相当多，这里简单对内存空间进行扫描，取出大概率实际用到的指令\n![alt text](image-7.png)\n举例分析几个指令：\n![alt text](image-8.png)\n![alt text](image-9.png)\n注意，我这里用的“弹”是偏主观的理解，按实际的来说，这里并没有专门的寄存器来接收“弹”出的栈顶变量，而是在语句中临时赋值。而后栈顶指针会往下移动，符合“弹”的感觉（x\n","slug":"ctf做题记录-svm","published":true,"updated":"2024-05-21T00:54:10.000Z","_id":"clxidry3v0003ccw054gearrm","comments":true,"layout":"post","photos":[],"html":"<h1><span id=\"待补完\">待补完</span></h1><p><img src=\"/2024/04/30/ctf%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95-svm/image.png\" alt=\"alt text\"><br>导入表为空，纯静态编译<br>经检查初始化和推出程序均空<br><img src=\"/2024/04/30/ctf%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95-svm/image-1.png\" alt=\"alt text\"><br><img src=\"/2024/04/30/ctf%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95-svm/image-2.png\" alt=\"alt text\"><br>程序执行会有 input 字符串，这是线索（这里用 ida 远程启动，会有其它信息<br><img src=\"/2024/04/30/ctf%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95-svm/image-3.png\" alt=\"alt text\"><br>input 直接在 string 中搜到，有如下交叉引用：<br><img src=\"/2024/04/30/ctf%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95-svm/image-4.png\" alt=\"alt text\"><br>直接下断点动调，发现 1780 是 main 函数，会 printf(input)<br><img src=\"/2024/04/30/ctf%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95-svm/image-5.png\" alt=\"alt text\"><br>init 函数做了一个初始化：<br><img src=\"/2024/04/30/ctf%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95-svm/image-6.png\" alt=\"alt text\"><br>sub_402000 是一个大虚拟机，不多赘述。<br>那么按照虚拟机的思路对函数重新命名</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">__int64 <span class=\"title\">sub_401780</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  __int64 vm_mem[<span class=\"number\">5</span>]; <span class=\"comment\">// [rsp+0h] [rbp+0h] BYREF</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> __int64 vars28; <span class=\"comment\">// [rsp+28h] [rbp+28h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  vars28 = __readfsqword(<span class=\"number\">0x28</span>u);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;input:&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">init</span>(vm_mem, &amp;mem_src, <span class=\"number\">4096LL</span>, <span class=\"number\">2677LL</span>);</span><br><span class=\"line\">  <span class=\"built_in\">vm</span>(vm_mem);</span><br><span class=\"line\">  <span class=\"built_in\">may_printf</span>(vm_mem[<span class=\"number\">0</span>]);</span><br><span class=\"line\">  <span class=\"built_in\">may_printf</span>(vm_mem[<span class=\"number\">2</span>]);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( __readfsqword(<span class=\"number\">0x28</span>u) != vars28 )</span><br><span class=\"line\">    <span class=\"built_in\">sub_44C7D0</span>();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对虚拟机init的一些初始判断：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__int64 __fastcall init(struct_vm *vm, __int64 a2, <span class=\"built_in\">int</span> mem_size, <span class=\"built_in\">int</span> code_size)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  __m128i *mem; // rax</span><br><span class=\"line\">  __int64 code_seg; // rax</span><br><span class=\"line\">  __int64 result; // rax</span><br><span class=\"line\"></span><br><span class=\"line\">  mem = (__m128i *)malloc(4LL * mem_size);</span><br><span class=\"line\">  vm-&gt;mem_size = mem_size;</span><br><span class=\"line\">  vm-&gt;mem = mem;</span><br><span class=\"line\">  memset(mem, <span class=\"number\">0</span>, <span class=\"number\">4</span> * mem_size);</span><br><span class=\"line\">  code_seg = malloc(4LL * code_size);</span><br><span class=\"line\">  vm-&gt;code_szie = code_size;</span><br><span class=\"line\">  vm-&gt;code_seg = code_seg;</span><br><span class=\"line\">  result = sub_401060();</span><br><span class=\"line\">  vm-&gt;ip_point = <span class=\"number\">0</span>;</span><br><span class=\"line\">  vm-&gt;stack = -1LL;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在当前这一步，我们可以确定的分析不多，但有一点———该虚拟机似乎缺少了对寄存器的初始化，只进行了两个内存空间——很可能是代码和栈空间的初始化；接下来我们会印证这个想法。<br>该虚拟机的指令相当多，这里简单对内存空间进行扫描，取出大概率实际用到的指令<br><img src=\"/2024/04/30/ctf%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95-svm/image-7.png\" alt=\"alt text\"><br>举例分析几个指令：<br><img src=\"/2024/04/30/ctf%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95-svm/image-8.png\" alt=\"alt text\"><br><img src=\"/2024/04/30/ctf%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95-svm/image-9.png\" alt=\"alt text\"><br>注意，我这里用的“弹”是偏主观的理解，按实际的来说，这里并没有专门的寄存器来接收“弹”出的栈顶变量，而是在语句中临时赋值。而后栈顶指针会往下移动，符合“弹”的感觉（x</p>\n","excerpt":"","more":"<h1 id=\"待补完\"><a href=\"#待补完\" class=\"headerlink\" title=\"待补完\"></a>待补完</h1><p><img src=\"/2024/04/30/ctf%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95-svm/image.png\" alt=\"alt text\"><br>导入表为空，纯静态编译<br>经检查初始化和推出程序均空<br><img src=\"/2024/04/30/ctf%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95-svm/image-1.png\" alt=\"alt text\"><br><img src=\"/2024/04/30/ctf%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95-svm/image-2.png\" alt=\"alt text\"><br>程序执行会有 input 字符串，这是线索（这里用 ida 远程启动，会有其它信息<br><img src=\"/2024/04/30/ctf%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95-svm/image-3.png\" alt=\"alt text\"><br>input 直接在 string 中搜到，有如下交叉引用：<br><img src=\"/2024/04/30/ctf%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95-svm/image-4.png\" alt=\"alt text\"><br>直接下断点动调，发现 1780 是 main 函数，会 printf(input)<br><img src=\"/2024/04/30/ctf%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95-svm/image-5.png\" alt=\"alt text\"><br>init 函数做了一个初始化：<br><img src=\"/2024/04/30/ctf%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95-svm/image-6.png\" alt=\"alt text\"><br>sub_402000 是一个大虚拟机，不多赘述。<br>那么按照虚拟机的思路对函数重新命名</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">__int64 <span class=\"title\">sub_401780</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  __int64 vm_mem[<span class=\"number\">5</span>]; <span class=\"comment\">// [rsp+0h] [rbp+0h] BYREF</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> __int64 vars28; <span class=\"comment\">// [rsp+28h] [rbp+28h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  vars28 = __readfsqword(<span class=\"number\">0x28</span>u);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;input:&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">init</span>(vm_mem, &amp;mem_src, <span class=\"number\">4096LL</span>, <span class=\"number\">2677LL</span>);</span><br><span class=\"line\">  <span class=\"built_in\">vm</span>(vm_mem);</span><br><span class=\"line\">  <span class=\"built_in\">may_printf</span>(vm_mem[<span class=\"number\">0</span>]);</span><br><span class=\"line\">  <span class=\"built_in\">may_printf</span>(vm_mem[<span class=\"number\">2</span>]);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( __readfsqword(<span class=\"number\">0x28</span>u) != vars28 )</span><br><span class=\"line\">    <span class=\"built_in\">sub_44C7D0</span>();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对虚拟机init的一些初始判断：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__int64 __fastcall init(struct_vm *vm, __int64 a2, <span class=\"built_in\">int</span> mem_size, <span class=\"built_in\">int</span> code_size)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  __m128i *mem; // rax</span><br><span class=\"line\">  __int64 code_seg; // rax</span><br><span class=\"line\">  __int64 result; // rax</span><br><span class=\"line\"></span><br><span class=\"line\">  mem = (__m128i *)malloc(4LL * mem_size);</span><br><span class=\"line\">  vm-&gt;mem_size = mem_size;</span><br><span class=\"line\">  vm-&gt;mem = mem;</span><br><span class=\"line\">  memset(mem, <span class=\"number\">0</span>, <span class=\"number\">4</span> * mem_size);</span><br><span class=\"line\">  code_seg = malloc(4LL * code_size);</span><br><span class=\"line\">  vm-&gt;code_szie = code_size;</span><br><span class=\"line\">  vm-&gt;code_seg = code_seg;</span><br><span class=\"line\">  result = sub_401060();</span><br><span class=\"line\">  vm-&gt;ip_point = <span class=\"number\">0</span>;</span><br><span class=\"line\">  vm-&gt;stack = -1LL;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在当前这一步，我们可以确定的分析不多，但有一点———该虚拟机似乎缺少了对寄存器的初始化，只进行了两个内存空间——很可能是代码和栈空间的初始化；接下来我们会印证这个想法。<br>该虚拟机的指令相当多，这里简单对内存空间进行扫描，取出大概率实际用到的指令<br><img src=\"/2024/04/30/ctf%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95-svm/image-7.png\" alt=\"alt text\"><br>举例分析几个指令：<br><img src=\"/2024/04/30/ctf%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95-svm/image-8.png\" alt=\"alt text\"><br><img src=\"/2024/04/30/ctf%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95-svm/image-9.png\" alt=\"alt text\"><br>注意，我这里用的“弹”是偏主观的理解，按实际的来说，这里并没有专门的寄存器来接收“弹”出的栈顶变量，而是在语句中临时赋值。而后栈顶指针会往下移动，符合“弹”的感觉（x</p>\n","path":"2024/04/30/ctf做题记录-svm/","permalink":"http://example.com/2024/04/30/ctf%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95-svm/","tags":[{"name":"CTF","_id":"clxidry3z000bccw01dimat95","slug":"CTF","path":"tags/CTF/","permalink":"http://example.com/tags/CTF/","length":3}],"categories":[],"prev":{"title":"XPATH报错注入小记","date":"2024-05-16T07:08:09.000Z","slug":"报错注入小记","published":true,"updated":"2024-05-16T07:47:06.000Z","_id":"clxidry43000mccw02k9r3fgu","layout":"post","photos":[],"excerpt":"","path":"2024/05/16/报错注入小记/","permalink":"http://example.com/2024/05/16/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%E5%B0%8F%E8%AE%B0/","__post":true},"next":{"title":"some frida scripts","date":"2024-04-30T02:44:22.000Z","slug":"some-frida-scripts","published":true,"updated":"2024-04-30T03:43:12.000Z","_id":"clxidry3y0007ccw04t9i754b","layout":"post","photos":[],"excerpt":"","path":"2024/04/30/some-frida-scripts/","permalink":"http://example.com/2024/04/30/some-frida-scripts/","__post":true},"__post":true}